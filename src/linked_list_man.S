// #include "include/linked_list.h"
.global createNode
.global insertNodeHead
.global printList
.global destroyList
// this C struct is 28 bytes large
// but GCC aligns this to 32 bytes, so we will try to follow that.

//typedef struct Node{
//    PlayerType player; // 0 for player 1, 1 for player 2 -1 for AI
//    int row;
//    int col;
//    struct Node* Next;
//    struct Node* Prev;
//}Node;

// macro definitions
/// loads a string using ADRP and adds the lower 12 bits address back
// ADRP X2, newline_str;
// ADD X2, X2, :lo12:newline_str;
.macro load_string str, reg
    ADRP \reg, \str
    ADD \reg, \reg, :lo12:\str
.endm

/// macro to call functions, assumes that the arguments are already inside the register
.macro simple_function_call func
    STP X29, X30, [SP, -16]! // store frame pointer and subtract 16 from current stack ptr
    MOV	x29, SP	//,

    .ifnb \func
        BL \func
    .endif
    
    // pop out the value of stack ptr
    LDP X29, X30, [SP], 16;
.endm

// these macros call malloc and free with stack pointer manipulation (for leaf functions)
.macro malloc size
    MOV R0, \size
    simple_function_call malloc
.endm

.macro free reg
    MOV R0, \reg
    simple_function_call free
.endm

createNode:
	stp	x29, x30, [sp, -64]!	// function stack
	mov	x29, sp

    // get the stack variables from C, because this function has more arguments than can fit in the registers.
	stp	x19, x20, [sp, 16]
	stp	x21, x22, [sp, 32]
	str	x23, [sp, 48]
    // stack variables are always 64 bit registers

    // assign them to the proper registers to avoid register clobbering
    MOV	W22, W0	// player (32 bit integer, enum) 4
	MOV	W23, W1	// row (32 bit integer) 4
	MOV	W21, W2	// col (32 bit integer) 4
	MOV	X20, X3	// next (ptr to Node* next) 8
	MOV	X19, X4	// prev (ptr to Node* prev) 8

    // malloc 32 Bytes
    MOV X0, 32
    BL malloc

    // check if X0 is a null pointer, as malloc can fail sometimes
    CBZ X0, if_nullptr
    B end_if // skip the statement entirely (else) 
    if_nullptr:
        // exit the program if null pointer and print an error
        load_string .malloc_error_str, X0
        bl printf
        MOV X0, #1
        bl exit
    end_if:

    // assign values to memory address in X0 to the struct defined ordering
	STR	w22, [x0]	// player, ret->player (32 bit integer)
	STR	w23, [x0, 4]	// ret->row (32 bit integer)
	STR	w21, [x0, 8]	// ret->col (32 bit integer)

    // gcc transparently adds the alignment here, skipping 12 to 16.

	STR	x20, [x0, 16]	// ret->Next (ptr)
	STR	x19, [x0, 24]	// ret->Prev (ptr)

    // push the stack back, using values generated by GCC in order to maintain interop with C
    ldp	x19, x20, [sp, 16]	//,,
	ldp	x21, x22, [sp, 32]	//,,
	ldr	x23, [sp, 48]	//,
	ldp	x29, x30, [sp], 64	//,,,
    RET

insertNodeHead:
    // create temp register X2 to store dereference of **head
    // node is X1
    LDR X2, [X0]
    STR X2, [X1, 24] //node -> prev = *head
    STR XZR, [X1, 16] // node -> next = null

    //My GCC Reference addds this extra load instruction which i think is redundant
    // 	ldr	x2, [x0]	// _2, *head_4(D)
    
    STR X1, [X2, 16] // *head->next = node
    STR X1, [X0] // *head = node
    RET

insertNodeTail:
    // create temp register X2 to store dereference of **tail
    // node is X1
    LDR X2, [X0]
    STR X2, [X1, 16] //node -> next = *tail
    STR XZR, [X1, 24] // node -> prev = null

    //My GCC Reference addds this extra load instruction which i think is redundant
    // 	ldr	x2, [x0]	// _2, *head_4(D)
    
    STR X1, [X2, 24] // *tail->prev = node
    STR X1, [X0] // *tail = node
    RET

printList:
	stp	x29, x30, [sp, -32]!
	mov	x29, sp
	stp	x19, x20, [sp, 16]

    // get the head of the list from argument, and load it into the first calle-saved register
	MOV	X19, X0	
	MOV	W20, #0	    // Create a variable i to store an iterator
    while_printlist:
        LDR	W2, [X19, 4] // load the Row variable (as an example) from struct to print out (alignment 4 bytes)
        MOV	W1, W20
        load_string .print_list_str, X0

        // println node %d contains %d (X0), i val (W1), node->row (W2) 
        BL println

        LDR	X19, [X19, 24]
        ADD	w20, w20, 1	// i++
        CBNZ X19, while_printlist
        B end_while_printlist
    end_while_printlist:

    // standard stack pointer pop
	ldp	x19, x20, [sp, 16]
	ldp	x29, x30, [sp], 32
	ret	

destroyList:
    // standard stack pointer manipulation generated by GCC
    stp  x29, x30, [sp, -32]!
    mov  x29, sp
    str  x19, [sp, 16]

    MOV X20, X0
    while:
        MOV X0, X20 // t = head;
        LDR X20, [X20, 24] // load node-> next

        BL free // free t
        
        CBZ X20, end_while // branch to end when X20 is a nullptr
        B while
    end_while:

    // standard stack pointer manipulation generated by GCC
    ldr  x19, [sp, 16]  //,
    ldp  x29, x30, [sp], 32  //,,,
    RET
.data
.malloc_error_str:
	.asciz	"Memory allocation failed in createNode! This might be an Operating System Issue! Terminating.\n"

.print_list_str:
	.asciz	"node %d contains %d"
    .align 4
